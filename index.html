<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ERROR 417</title>
  <link rel="stylesheet" href="style.css" />
</head>

<body tabindex="0">
  
  <div id="mode-indicator">
    <span>TAB</span> TOGGLE.MODE
  </div>
  <div class="terminal">
    <div class="typing-line">
      <span id="typed"></span><span class="caret"></span>
    </div>
    <canvas id="scene" width="1500" height="800"></canvas>
  </div>

  <div class="crt-overlay"></div>

  <div id="escape-overlay">
    <div id="escape-text">congratulations, you've found the way out :) </div>
    <button id="restart-button">restart</button>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script>
    const { Engine, Render, Runner, Bodies, World, Composite, Body, Events, Mouse, MouseConstraint, Vector } = Matter;

    const canvas = document.getElementById('scene');
    const ctx = canvas.getContext('2d');
    const engine = Engine.create();
    const render = Render.create({
      canvas,
      engine,
      options: {
        width: canvas.width,
        height: canvas.height,
        background: 'transparent', // let CRT background show through
        wireframes: false,
        pixelRatio: window.devicePixelRatio || 1
      }
    });

    const runner = Runner.create();
    Render.run(render);
    Runner.run(runner, engine);
    engine.gravity.y = 1.2;

    let mode = 1; // 1=drag, 2=magnet, 3=blower
    let isFloating = false; // --- NEW: Added floating state ---
    const state = { cols: 22, charSize: 26, buffer: '' };

    const mouse = Mouse.create(canvas);
    const cursor = { x: 0, y: 0 };
    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      cursor.x = e.clientX - rect.left;
      cursor.y = e.clientY - rect.top;
    });

    // --- UPDATED: Listen for 'Tab' and 'Escape' ---
    window.addEventListener('keydown', e => {
      if (e.key === 'Tab') {
        e.preventDefault(); // Stop browser from changing focus
        mode = (mode % 3) + 1; // Cycles 1 -> 2 -> 3 -> 1
      }
      
      // --- NEW: Added 'Escape' key logic ---
      if (e.key === 'Escape') {
        e.preventDefault();
        isFloating = true;
        document.getElementById('escape-overlay').style.display = 'flex';
      }
    });

    // explosion (on click)
    canvas.addEventListener('click', e => {
      if (isFloating) return; // Don't explode if floating
      const bodies = Composite.allBodies(engine.world);
      bodies.forEach(b => {
        if (!b.isStatic) {
          const dx = b.position.x - cursor.x;
          const dy = b.position.y - cursor.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 120) {
            const force = Vector.mult(Vector.normalise({ x: dx, y: dy }), 0.02);
            Body.applyForce(b, b.position, force);
          }
        }
      });
    });

    // --- drag constraint, disabled by default ---
    const mConstraint = MouseConstraint.create(engine, {
      mouse,
      constraint: { stiffness: 0.15, render: { visible: false } },
      enabled: false // Disabled by default, our 'beforeUpdate' loop will manage it
    });
    World.add(engine.world, mConstraint);

    // --- UPDATED: Main physics loop to handle all modes OR floating ---
    Events.on(engine, 'beforeUpdate', () => {
      
      // --- NEW: Floating logic takes priority ---
      if (isFloating) {
        engine.gravity.y = 0; // Turn off gravity
        mConstraint.enabled = false; // Disable dragging
        
        const bodies = Composite.allBodies(engine.world);
        bodies.forEach(b => {
          if (!b.isStatic) {
            // Apply a tiny random "drift" force to make them float around
            const force = { 
              x: (Math.random() - 0.5) * 0.002, 
              y: (Math.random() - 0.5) * 0.002 
            };
            Body.applyForce(b, b.position, force);
          }
        });
        return; // Skip the normal mode logic
      }

      // --- Original Mode Logic ---
      
      // Set drag constraint active only for mode 1
      mConstraint.enabled = (mode === 1);

      const bodies = Composite.allBodies(engine.world);
      const magnetRadiusSq = 20000; // Shared radius for magnet/blower
      const magnetStrength = 0.005; // Shared strength (You increased this)

      // Mode 2: Magnet (Pull)
      if (mode === 2) {
        bodies.forEach(b => {
          if (!b.isStatic) {
            const dx = cursor.x - b.position.x;
            const dy = cursor.y - b.position.y;
            const distSq = dx * dx + dy * dy;
            if (distSq < magnetRadiusSq) {
              const force = Vector.mult(Vector.normalise({ x: dx, y: dy }), magnetStrength);
              Body.applyForce(b, b.position, force);
            }
          }
        });
      }
      // Mode 3: Blower (Push)
      else if (mode === 3) {
        bodies.forEach(b => {
          if (!b.isStatic) {
            const dx = b.position.x - cursor.x; 
            const dy = b.position.y - cursor.y;
            const distSq = dx * dx + dy * dy;
            if (distSq < magnetRadiusSq) {
              const force = Vector.mult(Vector.normalise({ x: dx, y: dy }), magnetStrength);
              Body.applyForce(b, b.position, force);
            }
          }
        });
      }
    });


    // walls
    const W = render.options.width;
    const H = render.options.height;
    const thickness = 40;
    const invisibleWall = { isStatic: true, render: { visible: false } };

    const floor = Bodies.rectangle(W / 2, H + thickness / 2 - 2, W, thickness, invisibleWall);
    const left = Bodies.rectangle(-thickness / 2, H / 2, thickness, H, invisibleWall);
    const right = Bodies.rectangle(W + thickness / 2, H / 2, thickness, H, invisibleWall);

    World.add(engine.world, [floor, left, right]);


    // draw text + cursor indicator
    Events.on(render, 'afterRender', () => {
      ctx.save();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#00ff80';
      ctx.shadowColor = '#00ff80';
      ctx.shadowBlur = 8;
      ctx.font = `${state.charSize}px ui-monospace, Menlo, Monaco, Consolas, monospace`;

      Composite.allBodies(engine.world).forEach(b => {
        const letter = b.plugin && b.plugin.letter;
        if (!letter) return;
        ctx.save();
        ctx.translate(b.position.x, b.position.y);
        ctx.rotate(b.angle);
        ctx.fillText(letter, 0, 2);
        ctx.restore();
      });

      // cursor ring
      ctx.beginPath();
      ctx.arc(cursor.x, cursor.y, 10, 0, 2 * Math.PI);
      
      ctx.strokeStyle = ['#00ff80', '#FFFFFF', '#0000FF'][mode - 1];
      
      ctx.lineWidth = 1.5;
      ctx.stroke();

      ctx.restore();
    });

    // typing logic
    const typedSpan = document.getElementById('typed');

    // Gets a random number between 1 and 100
    function getRandomLimit() {
      return Math.floor(Math.random() * 100) + 1;
    }

    // Set the initial limit
    let currentCharLimit = getRandomLimit();

    // A new function to handle the "fall" logic
    function triggerFall() {
      if (state.buffer.length === 0 || isFloating) return; // Don't fall if empty or floating
      dropWord(state.buffer);
      state.buffer = '';
      updateTyped();
      currentCharLimit = getRandomLimit(); // Set a new random limit for next time
    }
    
    function updateTyped() {
      typedSpan.textContent = state.buffer;
    }

    function dropWord(word) {
      const cell = W / state.cols;
      let col = 0;
      const bodies = [];
      for (let i = 0; i < word.length; i++) {
        const ch = word[i];
        const x = Math.round(col * cell + cell / 2);
        const y = -40;
        const w = state.charSize * 0.8;
        const h = state.charSize;
        const body = Bodies.rectangle(x, y, w, h, {
          restitution: 0.15,
          friction: 0.35,
          frictionAir: 0.02,
          density: 0.001,
          render: { visible: false }
        });
        body.plugin = { letter: ch };
        Body.setAngularVelocity(body, (Math.random() - 0.5) * 0.25);
        Body.setVelocity(body, { x: (Math.random() - 0.5) * 1.2, y: 0 });
        bodies.push(body);
        col = (col + 1) % state.cols;
      }
      World.add(engine.world, bodies);
    }

    // --- UPDATED KEYDOWN LISTENER (This is for typing) ---
    document.addEventListener('keydown', (event) => {
      const key = event.key;
      
      if (isFloating) return; // --- NEW: Disable typing when floating

      if (key === 'Backspace') {
        event.preventDefault();
        state.buffer = state.buffer.slice(0, -1);
        updateTyped();
        return;
      }

      // Condition 1: User presses Enter
      if (key === 'Enter') {
        event.preventDefault();
        triggerFall(); // Use our new helper function
        return;
      }

      // This is where we check the length
      if (key.length === 1) {
        state.buffer += key;
        updateTyped();

        // Condition 2: Check if buffer length passes the random limit
        if (state.buffer.length > currentCharLimit) {
          triggerFall(); // Use our new helper function
        }
      }
    });

    // --- UPDATED: Added click listener for restart button ---
    window.addEventListener('load', () => {
      document.body.focus();
      document.getElementById('restart-button').addEventListener('click', () => {
        location.reload();
      });
    });
  </script>
</body>
</html>